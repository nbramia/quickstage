#!/usr/bin/env node

const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');

async function releaseWorkflow() {
  try {
    console.log('üöÄ QuickStage Extension Release Workflow');
    console.log('=====================================\n');

    // Step 1: Bump version
    console.log('1Ô∏è‚É£ Bumping version...\n');
    execSync('npm run version:bump', { stdio: 'inherit' });
    console.log('‚úÖ Version bumped successfully\n');

    // Step 2: Build extension
    console.log('2Ô∏è‚É£ Building extension...\n');
    execSync('npm run build', { stdio: 'inherit' });
    console.log('‚úÖ Extension built successfully\n');

    // Step 3: Clean up old VSIX files first
    console.log('3Ô∏è‚É£ Cleaning up old VSIX files...\n');
    const oldVsixFiles = fs.readdirSync(__dirname).filter(f => f.endsWith('.vsix'));
    oldVsixFiles.forEach(file => {
      fs.unlinkSync(path.join(__dirname, file));
      console.log(`üóëÔ∏è Removed old VSIX: ${file}`);
    });
    
    // Step 4: Package extension
    console.log('4Ô∏è‚É£ Packaging extension...\n');
    execSync('npm run package', { stdio: 'inherit' });
    console.log('‚úÖ Extension packaged successfully\n');

    // Step 4.5: Wait for file to be fully written and verify
    console.log('‚è≥ Waiting for VSIX file to be fully written...\n');
    await new Promise(resolve => setTimeout(resolve, 1000)); // Wait 1 second
    
    // Read version for filenames
    const packageJson = JSON.parse(fs.readFileSync('package.json', 'utf8'));
    const version = packageJson.version;
    
    // Find the specific VSIX file that matches current version
    const expectedVsixName = `quickstage-${version}.vsix`;
    const vsixSource = path.join(__dirname, expectedVsixName);
    
    if (!fs.existsSync(vsixSource)) {
      throw new Error(`Expected VSIX file not found: ${expectedVsixName}`);
    }
    
    // Verify the VSIX is valid before copying
    console.log('üîç Verifying local VSIX structure...\n');
    try {
      const localVsixCheck = execSync(`unzip -l "${vsixSource}"`, { encoding: 'utf8' });
      console.log('üì¶ Local VSIX contents:');
      console.log(localVsixCheck);
      
      if (!localVsixCheck.includes('extension/package.json')) {
        throw new Error('Local VSIX missing extension/package.json - packaging failed!');
      }
      console.log('‚úÖ Local VSIX structure verified correctly\n');
    } catch (error) {
      console.error('‚ùå Local VSIX verification failed:', error.message);
      throw new Error('Local VSIX structure is incorrect - cannot proceed');
    }

    // Step 5: Copy VSIX to web app public directory for direct serving
    console.log('5Ô∏è‚É£ Copying VSIX to web app for direct serving...\n');
    const webPublicDir = path.join(__dirname, '../web/public');
    
    // Create public directory if it doesn't exist
    if (!fs.existsSync(webPublicDir)) {
      fs.mkdirSync(webPublicDir, { recursive: true });
    }
    
    // Copy VSIX to web app public directory
    fs.copyFileSync(vsixSource, path.join(webPublicDir, 'quickstage.vsix'));
    
    // Also copy with versioned filename for cache busting
    const versionedFilename = `quickstage-${version}.vsix`;
    fs.copyFileSync(vsixSource, path.join(webPublicDir, versionedFilename));
    
    console.log('‚úÖ VSIX copied to web app public directory\n');
    console.log(`üì¶ Files created: quickstage.vsix and ${versionedFilename}\n`);

    // Step 5.5: Verify VSIX structure before proceeding
    console.log('üîç Verifying VSIX structure...\n');
    
    try {
      // Check VSIX contents to ensure correct structure
      const vsixCheck = execSync(`unzip -l "${path.join(webPublicDir, 'quickstage.vsix')}"`, { encoding: 'utf8' });
      console.log('üì¶ VSIX contents:');
      console.log(vsixCheck);
      
      // Verify package.json is in the right place
      if (!vsixCheck.includes('extension/package.json')) {
        throw new Error('VSIX missing extension/package.json - structure is incorrect!');
      }
      
      console.log('‚úÖ VSIX structure verified correctly\n');
    } catch (error) {
      console.error('‚ùå VSIX structure verification failed:', error.message);
      throw new Error('VSIX structure is incorrect - cannot proceed with deployment');
    }

    // Step 6: Update web app version info
    console.log('6Ô∏è‚É£ Updating web app version info...\n');
    
    // Update web app's version info file
    const webVersionFile = path.join(__dirname, '../web/src/version.ts');
    const timestamp = new Date().toISOString();
    const versionContent = `// Auto-generated by release workflow
export const EXTENSION_VERSION = '${version}';
export const EXTENSION_DOWNLOAD_URL = '/quickstage.vsix';
export const EXTENSION_VERSIONED_URL = '/quickstage-${version}.vsix';
export const EXTENSION_CHECK_URL = '/api/extensions/version';
export const EXTENSION_BUILD_TIME = '${timestamp}';
`;
    
    fs.writeFileSync(webVersionFile, versionContent);
    console.log('‚úÖ Web app version info updated\n');

    // Step 7: Update worker version info
    console.log('7Ô∏è‚É£ Updating worker version info...\n');
    
    // Update worker's version info file
    const workerVersionFile = path.join(__dirname, '../worker/src/version-info.ts');
    const workerVersionContent = `// Auto-generated by release workflow - DO NOT EDIT MANUALLY
// This file is automatically updated when the extension version changes

export function getExtensionVersion() {
  return {
    version: '${version}', // Synced from extension/package.json
    buildDate: new Date().toISOString(),
    filename: 'quickstage.vsix'
  };
}
`;
    
    fs.writeFileSync(workerVersionFile, workerVersionContent);
    console.log('‚úÖ Worker version info updated\n');

    // Step 8: Build worker with new version
    console.log('8Ô∏è‚É£ Building worker with new version...\n');
    try {
      execSync('cd ../worker && pnpm build', { stdio: 'inherit' });
      console.log('‚úÖ Worker built successfully\n');
    } catch (error) {
      console.error('‚ùå Worker build failed:', error.message);
      throw new Error('Worker build failed - cannot proceed');
    }

    // Step 9: Deploy worker automatically
    console.log('9Ô∏è‚É£ Deploying worker with new version...\n');
    try {
      execSync('cd ../../infra && npx wrangler deploy', { stdio: 'inherit' });
      console.log('‚úÖ Worker deployed successfully\n');
    } catch (error) {
      console.error('‚ùå Worker deployment failed:', error.message);
      throw new Error('Worker deployment failed - cannot proceed');
    }

    console.log('üéâ Release workflow completed successfully!');
    console.log(`üì¶ Extension v${version} is ready and worker is deployed\n`);
    
    console.log('üìã Final step:');
    console.log('1. Build the web app: cd apps/web && pnpm build');
    console.log('2. Deploy the web app: cd ../../infra && npx wrangler pages deploy dist --project-name=quickstage');
    console.log('3. Test the new extension download from the dashboard');
    console.log(`4. The new version ${version} will be automatically detected by users`);
    console.log('5. Worker is already deployed with the new version!');

  } catch (error) {
    console.error('‚ùå Release workflow failed:', error);
    process.exit(1);
  }
}

releaseWorkflow();
